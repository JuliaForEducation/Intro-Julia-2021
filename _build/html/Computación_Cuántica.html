
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Computación Cuántica &#8212; Project-oriented workshop in Julia computing</title>
    
  <link rel="stylesheet" href="_static/css/index.d431a4ee1c1efae0e38bdfebc22debff.css">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="_static/sphinx-book-theme.bfb7730f9caf2ec0b46a44615585038c.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.30270b6e4c972e43c488.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/translations.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.be0a4a0c39cd630af62a2fcf693f3f06.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="shortcut icon" href="_static/logo.ico"/>
    <link rel="index" title="Índice" href="genindex.html" />
    <link rel="search" title="Búsqueda" href="search.html" />
    <link rel="next" title="Primer proyecto" href="Primer_proyecto.html" />
    <link rel="prev" title="Natural Language Processing" href="Natural_Language_Processing.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
  
  <img src="_static/julia_logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Project-oriented workshop in Julia computing</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Buscar este libro ..." aria-label="Buscar este libro ..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="Intro.html">
   Project-oriented workshop in Julia computing
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Primera Semana
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="Git_y_GitHub.html">
   Git y GitHub
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Fundamentos.html">
   Fundamentos
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Estructuras_de_Control.html">
   Estructuras de Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Estructuras_de_Datos.html">
   Estructuras de Datos
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Segunda Semana
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="Paquete_Plots.html">
   Paquete Plots
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Ecuaciones_diferenciales.html">
   Ecuaciones diferenciales
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Paquete_DataFrames.html">
   Paquete DataFrames
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="Natural_Language_Processing.html">
   Natural Language Processing
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Tercera Semana
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Computación Cuántica
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Proyectos
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="Primer_proyecto.html">
   Primer proyecto
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lista_proyectos.html">
   Opciones proyectos segunda semana
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Navegación de palanca" aria-controls="site-navigation"
            title="Navegación de palanca" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Descarga esta pagina"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/Computación_Cuántica.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Descargar archivo fuente" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Imprimir en PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/JuliaForEducation/Intro-Julia-2021"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Repositorio de origen"><i
                    class="fab fa-github"></i>repositorio</button></a>
        <a class="issues-button"
            href="https://github.com/JuliaForEducation/Intro-Julia-2021/issues/new?title=Issue%20on%20page%20%2FComputación_Cuántica.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Abrir un problema"><i class="fas fa-lightbulb"></i>Tema abierto</button></a>
        <a class="edit-button" href="https://github.com/JuliaForEducation/Intro-Julia-2021/edit/master/Computación_Cuántica.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edita esta página"><i class="fas fa-pencil-alt"></i>Tema abierto</button></a>
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Modo de pantalla completa"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/JuliaForEducation/Intro-Julia-2021/master?urlpath=tree/Computación_Cuántica.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Lanzamiento Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <a class="colab-button" href="https://colab.research.google.com/github/JuliaForEducation/Intro-Julia-2021/blob/master/Computación_Cuántica.ipynb"><button type="button" class="btn btn-secondary topbarbtn"
                title="Lanzamiento Colab" data-toggle="tooltip" data-placement="left"><img class="colab-button-logo"
                    src="_static/images/logo_colab.png"
                    alt="Interact on Colab">Colab</button></a>
        
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contenido
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#preliminares">
   Preliminares
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#abstraccion-a-nivel-de-circuito">
   Abstracción a nivel de circuito
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#diseno-de-un-circuito">
     Diseño de un circuito
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#registro-de-estados">
     Registro de estados
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#registros-completamente-activos">
       Registros completamente activos
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#registros-enfocados">
       Registros enfocados
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#aritmetica-de-registros">
       Aritmética de registros
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#compuertas-logicas-y-mediciones">
     Compuertas lógicas y mediciones
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#mediciones">
       Mediciones
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#compuertas-comunes">
       Compuertas comunes
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#compuertas-de-control">
       Compuertas de control
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#aplicando-bloques-a-registros">
       Aplicando bloques a registros
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#metricas-de-comparacion-de-registros">
       Métricas de comparación de registros
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#algoritmica">
   Algorítmica
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#transformada-cuantica-de-fourier">
     Transformada cuántica de Fourier
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#estimacion-de-fase">
     Estimación de fase
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="computacion-cuantica">
<h1>Computación Cuántica<a class="headerlink" href="#computacion-cuantica" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="preliminares">
<h2>Preliminares<a class="headerlink" href="#preliminares" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Este material presenta una introducción a la algorítmica básica en el cómputo cuántico, así como conceptos periféricos, utilizando la interfaz de programación contenida en el paquete <code class="docutils literal notranslate"><span class="pre">Yao</span></code> en Julia.</p>
<p>La computacón cuántica es un área mucho más extensa que solo lo que se discutirá aquí, e incluso actualmente no se tiene un panorama consensuado de lo que deberían ser las <strong>capas, arquitectura o flujo de la computación cuántica</strong>, comenzando desde su implementación física hasta cualquier aplicación que haga uso abstracto de dicha implementación.</p>
<p>No obstante, para ejemplificar una posible visión, mostramos la siguiente imagen:</p>
<p><img alt="Capas_QC" src="https://upload.wikimedia.org/wikipedia/commons/f/fa/Jones-2012-figure01.png" /></p>
<p>Aquí podemos apreciar que la algorítmica es una abstracción de las posibles implementaciones físicas que pueden existir y además es resultado de un conjunto de asunciones teóricas que se deben procurar garantizar en las implementaciones mediante cuidados de la capa 2: Virtual (corrección de error, desacoplamiento dinámico, ciclo de control-retroalimentación del sistema, etc.)</p>
</div>
<div class="section" id="abstraccion-a-nivel-de-circuito">
<h2>Abstracción a nivel de circuito<a class="headerlink" href="#abstraccion-a-nivel-de-circuito" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="diseno-de-un-circuito">
<h3>Diseño de un circuito<a class="headerlink" href="#diseno-de-un-circuito" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En la algorítmica del cómputo cuántico trabajamos con los siguientes objetos abstractos (que pueden ser implementados de diversas maneras físicamente):</p>
<ul class="simple">
<li><p>Registros de qubits</p></li>
<li><p>compuertas lógicas cuántica</p></li>
<li><p>Aparatos de medición</p></li>
<li><p>Ligaduras de control</p></li>
</ul>
<p>Para proveer un ejemplo de un diagrama que contenga todos estos elementos considere el siguiente:</p>
<p><img alt="diagrama_circuito" src="https://tutorials.yaoquantum.org/dev/generated/quick-start/1.prepare-ghz-state/assets/ghz4.png" /></p>
<p>Tenemos un <strong>registro de qubits</strong> que consiste de los qubits <span class="math notranslate nohighlight">\(\{Q_0, Q_1, Q_2, Q_3\}\)</span>. Éstos están todos en el estado <span class="math notranslate nohighlight">\(|0\rangle\)</span>, como suele ser común para muchos algoritmos cuánticos.</p>
<p>Los cuadrados, etiquetado uno con una X y otros 7 con H, son ejemplos de compuertas lógicas. Respectivamente se les conoce como compuerta X de Pauli y compuerta de Hadamard.</p>
<p>Éstas, matemáticamente hablando, son operadores unitarios de los cuales, como es bien conocido, tenemos infinitos para cualquier espacio de Hilbert no trivial con el que trabajemos en nuestro sistema cuántico.</p>
<p>No obstante, elegimos darle nombres a éstas por permitir cálculos limpios en ciertas elecciones de base importantes que podemos realizar en el espacio de Hilbert. Las lineas verticales que conectan algunos de los qubits y poseen un nodo con <span class="math notranslate nohighlight">\(\oplus\)</span> y otro relleno son otro ejemplo de compuerta lógica, aunque más compleja</p>
<p>Éstas son compuertas de control que pueden influir en el estado de un qubit en base al estado de otro. Estas son un ejemplo de lo que llamamos <strong>compuertas compuestas</strong> que, matemáticamente, son operadores del espacio producto de los espacios de estado de los qubits involucrados.</p>
<p>Finalmente, al final de la linea de acción de cada uno de los qubits tenemos un elemento de diagrama que simboliza un aparato de medición. Éstos son necesarios para obtener la información contenida en los estados del registro, considerado el <strong>output</strong> o <strong>salida</strong> del algoritmo cuántico que este circuito representa.</p>
</div>
<div class="section" id="registro-de-estados">
<h3>Registro de estados<a class="headerlink" href="#registro-de-estados" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="section" id="registros-completamente-activos">
<h4>Registros completamente activos<a class="headerlink" href="#registros-completamente-activos" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Comencemos creando algunos registros. Primero cargamos el paquete <code class="docutils literal notranslate"><span class="pre">Yao</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">Pkg</span><span class="p">;</span> <span class="n">Pkg</span><span class="o">.</span><span class="n">activate</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">);</span> <span class="k">using</span> <span class="n">Yao</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Bold -Color-Bold-Green"> Activating</span> environment at `~/julia_for_education/book/Project.toml`
</pre></div>
</div>
</div>
</div>
<p>Podemos crear el registro del diagrama de arriba utilizando la función <code class="docutils literal notranslate"><span class="pre">zero_state</span></code> que nos otorga con facilidad este común registro de cualquier tamaño:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">zero_state</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 4/4
</pre></div>
</div>
</div>
</div>
<p>Como la naturaleza de la medición que obtenemos de los qubits es inevitablemente probabilística, a veces es deseado tener un número de <strong>batches</strong> o <strong>lotes</strong> que representan varias realizaciones del mismo circuito para obtener estadísticas.</p>
<p>En este siguiente comando creamos 5 lotes de un registro de 3 qubits, todos en el estado <span class="math notranslate nohighlight">\(|0\rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">zero_state</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">nbatch</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{5, Complex{Float64}, Transpose...}
    active qubits: 3/3
</pre></div>
</div>
</div>
</div>
<p>Podemos también construir un registro a partir de una cadena de bits que representa en análogo clásico del estado cuántico (respecto a alguna base):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">product_state</span><span class="p">(</span><span class="n">bit</span><span class="s">&quot;101&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 3/3
</pre></div>
</div>
</div>
</div>
<p>Para cualquier registro podemos extraer el estado explícito como arreglo de números complejos de la siguiente manera:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">product_state</span><span class="p">(</span><span class="n">bit</span><span class="s">&quot;101&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8×1 Array{Complex{Float64},2}:
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>Notemos que este vector no tendrá <span class="math notranslate nohighlight">\(3\)</span> elementos correspondiendo a los 3 digitos de la cadena de bits, si no que tendremos <span class="math notranslate nohighlight">\(8 = 2^3\)</span>.</p>
<p>Por supuesto podemos también construir más de un lote, y también cambiar el tipo de número complejo utilizando para guardar en memoria el estado:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">product_state</span><span class="p">(</span><span class="n">ComplexF32</span><span class="p">,</span> <span class="n">bit</span><span class="s">&quot;111&quot;</span><span class="p">,</span> <span class="n">nbatch</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{3, Complex{Float32}, Transpose...}
    active qubits: 3/3
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">product_state</span><span class="p">(</span><span class="n">ComplexF32</span><span class="p">,</span> <span class="n">bit</span><span class="s">&quot;111&quot;</span><span class="p">,</span> <span class="n">nbatch</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8×3 LinearAlgebra.Transpose{Complex{Float32},Array{Complex{Float32},2}}:
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im
 1.0+0.0im  1.0+0.0im  1.0+0.0im
</pre></div>
</div>
</div>
</div>
<p>A veces no necesitamos especificar el estado explícito, y queremos en su lugar generar un estado aleatorio (basándonos en una distribución binormal estándar) que nos permita poner a prueba cierto circuito independiente de sus entradas:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">rand_state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 2/2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span> <span class="n">rand_state</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">state</span> <span class="c">## Estado de 2 qubits tiene 2^2 = 4 entradas.</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4×1 Array{Complex{Float64},2}:
    0.1107591501016505 + 0.3746875639986465im
  -0.37422236954457866 + 0.48081350474536616im
 -0.020950316417709378 + 0.38913756410568046im
    0.4286192165726467 + 0.3748816339446155im
</pre></div>
</div>
</div>
</div>
<p>Otro registro comúnmente utilizado es el registro de estados uniformes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">uniform_state</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>16×1 Array{Complex{Float64},2}:
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
 0.25 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>Estos tienen la forma: <span class="math notranslate nohighlight">\(\frac{1}{n} \sum_k |k\rangle\)</span> y pueden ser similarmente obtenidos tras aplicar una compuerta de hadamar multidimensional a un registro de puros estados <span class="math notranslate nohighlight">\(|0\rangle\)</span> (es decir, una compuerta de hadamard <em>sencilla</em> por cada qubit).</p>
<p>Finalmente, mostramos que cualquier registro puede ser representado en su forma hiperbólica, es decir, como elemento de un espacio tensorial general.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">hypercubic</span><span class="p">(</span><span class="n">uniform_state</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×2×2×2×1 Array{Complex{Float64},5}:
[:, :, 1, 1, 1] =
 0.25+0.0im  0.25+0.0im
 0.25+0.0im  0.25+0.0im

[:, :, 2, 1, 1] =
 0.25+0.0im  0.25+0.0im
 0.25+0.0im  0.25+0.0im

[:, :, 1, 2, 1] =
 0.25+0.0im  0.25+0.0im
 0.25+0.0im  0.25+0.0im

[:, :, 2, 2, 1] =
 0.25+0.0im  0.25+0.0im
 0.25+0.0im  0.25+0.0im
</pre></div>
</div>
</div>
</div>
<p>Comparando dimensiones:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">uniform_state</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">state</span> <span class="o">|&gt;</span> <span class="n">size</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(16, 1)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span> <span class="n">hypercubic</span><span class="p">(</span><span class="n">uniform_state</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="o">|&gt;</span> <span class="n">size</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2, 2, 2, 2, 1)
</pre></div>
</div>
</div>
</div>
<p>El último muestra cómo el elemento del espacio vectorial de dimension 16 se entiende como un elemento de un espacio vectorial generado a partir de productos tensoriales de 4 espacios vectoriales de dimensión 2 (es decir, los espacios asociados a cada qubit individual).</p>
</div>
<div class="section" id="registros-enfocados">
<h4>Registros enfocados<a class="headerlink" href="#registros-enfocados" title="Enlazar permanentemente con este título">¶</a></h4>
<p>En la práctica, no todos los qubits presentes en el sistema que consideramos el “computador cuántico” son utilizados para realizar operaciones. Muchos están presentes para asistir a procedimientos de corrección de error o flujo de control entre componentes, pero éstos no son menos importantes de preservar bajo coherencia cuántica.</p>
<p>Estos qubits de ambiente, no obstante, deben ser considerados explícitamente ya que afectan el estado general del registro y <code class="docutils literal notranslate"><span class="pre">Yao</span></code> provee una interfaz para hacer eso. Considere el siguiente registro</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">zero_state</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">focus!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 3/5
</pre></div>
</div>
</div>
</div>
<p>Notemos que el resultado nos muestra solmente <span class="math notranslate nohighlight">\(3\)</span> de los <span class="math notranslate nohighlight">\(5\)</span> qubits como qubits activo. Estos qubits activos son lo que conocemos como <strong>qubits de sistema</strong> y son sobre lso que operaremos. El resto solo funcionan como ambiente. El estado general del registro sigue siendo el mismo que si todos fueran activos:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">zero_state</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">focus!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8×4 Array{Complex{Float64},2}:
 1.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
</pre></div>
</div>
</div>
</div>
<p>Pero en cualquier momento somos capaces de encontrar el número de qubits de sistema y qubits de ambiente de un registro dado:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ψ₁</span> <span class="o">=</span> <span class="n">zero_state</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">focus!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 3/5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">nqubits</span><span class="p">(</span><span class="n">ψ₁</span><span class="p">),</span> <span class="n">nactive</span><span class="p">(</span><span class="n">ψ₁</span><span class="p">),</span> <span class="n">nremain</span><span class="p">(</span><span class="n">ψ₁</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(5, 3, 2)
</pre></div>
</div>
</div>
</div>
<p>Si queremos “<em>relajar</em>” los qubits de ambiente hacia un estado de control con el cual podamos operar, se puede utilizar el comando <code class="docutils literal notranslate"><span class="pre">relax!</span></code> de las siguientes formas:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ψ₁</span> <span class="o">|&gt;</span> <span class="n">relax!</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 5/5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">relax!</span><span class="p">(</span><span class="n">ψ₁</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 5/5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">relax!</span><span class="p">(</span><span class="n">ψ₁</span><span class="p">,</span> <span class="n">to_nactive</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 4/5
</pre></div>
</div>
</div>
</div>
<p>En el último llamado se muestra que podemos controlar el número de qubits del sistema con el que queremos terminar. Note que no elegimos los índices de “cuales” qubits activar (recordando que antes estaban activos los de índice <code class="docutils literal notranslate"><span class="pre">5</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, y <code class="docutils literal notranslate"><span class="pre">2</span></code>).</p>
<p>Esto es porque el índice de cierto qubit es un ordemamiento arbitrario: No importa si consideramos que el registro activo consiste de los qubits que originalmente llamamos <span class="math notranslate nohighlight">\(\{5,2,3\}\)</span> o de otros, pues esas etiquetas originales fueron arbitrarias para la física.</p>
</div>
<div class="section" id="aritmetica-de-registros">
<h4>Aritmética de registros<a class="headerlink" href="#aritmetica-de-registros" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Podemos operar con la aritmética esperada sobre nuestros registros mientras sea teóricamente válida la operación.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">begin</span>
	<span class="n">ψ₂</span> <span class="o">=</span> <span class="n">rand_state</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
	<span class="n">ψ₃</span> <span class="o">=</span> <span class="n">rand_state</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> 
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 5/5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mf">0.3</span><span class="n">ψ₂</span> <span class="o">+</span> <span class="mi">2</span><span class="n">ψ₃</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 5/5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mf">0.3</span><span class="n">ψ₂</span> <span class="o">+</span> <span class="mi">2</span><span class="n">ψ₃</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">|&gt;</span> <span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>32×1 Array{Complex{Float64},2}:
   0.20563688655024925 + 0.04098790343565623im
   0.08383133162595909 + 0.055224202963223425im
   -0.1720975206277203 + 0.023190748584247044im
    0.3199444786012372 + 0.03822828758511488im
  -0.04721190056281986 + 0.05275530760213698im
    0.0878037817702425 - 0.1918655313357905im
   0.15476757236590205 + 0.15997137555126775im
   0.10810397864505639 + 0.08017231262802983im
   0.12686463513486704 - 0.1108864113580091im
  -0.23654755877154515 + 0.026759769983814925im
   0.04868013499444064 + 0.06747348259269467im
  -0.13439302049209376 - 0.07022981801411819im
    0.2532211305413657 - 0.024018848439077742im
                       ⋮
   0.04062497978215061 - 0.17780954773247407im
 -0.019529766240725808 + 0.07601048465035004im
   -0.1792061131707565 + 0.11735508066452076im
  0.016149066651152292 - 0.023698835834975545im
  -0.11452407994981921 - 0.02148523428891893im
   0.09158734785549058 + 0.019510532379093115im
   0.15800075437520011 + 0.11727031657599324im
 0.0011525463351538174 + 0.08606993423394994im
   -0.1456136916026627 + 0.09952448626790636im
  -0.08666495668133016 + 0.223065364470211im
   0.06761102480187127 - 0.02390731050199421im
  -0.04354340774046506 - 0.09329681192608498im
</pre></div>
</div>
</div>
</div>
<p>No obstante..</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mf">0.3</span><span class="n">ψ₂</span> <span class="o">+</span> <span class="mi">2</span><span class="n">ψ₃</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">|&gt;</span> <span class="n">isnormalized</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>false
</pre></div>
</div>
</div>
</div>
<p>Notamos que este nuevo estado no se normaliza por defecto. La <strong>Normalización</strong> es una condición requerida para los estados puros del sistema finito dimensional (como es nuestro caso. En casos más generales de sistemas cuánticos, esta condición se traduce a que el mapa lineal de densidad sea tipo traza con traza igual a 1).</p>
<p>Es decir, requerimos que la norma de la representación pura del estado (aquí denotados como <span class="math notranslate nohighlight">\(\psi\)</span>) sea igual a 1. Debemos siempre recordar que posterior a alguna operación, debemos normalizar de nuevo el vector representante del estado.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ψ₄</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.3</span><span class="n">ψ₂</span> <span class="o">+</span> <span class="mi">2</span><span class="n">ψ₃</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 5/5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ψ₄</span> <span class="o">|&gt;</span> <span class="n">normalize!</span> <span class="o">|&gt;</span> <span class="n">isnormalized</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>true
</pre></div>
</div>
</div>
</div>
<p>Exploramos ahora la norma:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ψ₄</span><span class="o">&#39;</span> <span class="o">*</span> <span class="n">ψ₄</span> <span class="c">## la comilla &#39; representa la operación de transposición en la base selecta.</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="compuertas-logicas-y-mediciones">
<h3>Compuertas lógicas y mediciones<a class="headerlink" href="#compuertas-logicas-y-mediciones" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="section" id="mediciones">
<h4>Mediciones<a class="headerlink" href="#mediciones" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Las compuertas lógicas son la forma en que podemos transformar los estados de los registros de qubits que hemos creados. En Yao estos se pueden definir, al igual que los aparatos de medición, en los denominados <strong>bloques</strong>.</p>
<p>Primero, preparemos un registro con la suma de dos registros y lo normalizamos posteriormente:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">normalize!</span><span class="p">(</span><span class="n">ArrayReg</span><span class="p">(</span><span class="n">bit</span><span class="s">&quot;000&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">ArrayReg</span><span class="p">(</span><span class="n">bit</span><span class="s">&quot;111&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 3/3
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">r</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8×1 Array{Complex{Float64},2}:
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
 0.7071067811865475 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>Medir este registro es tan sencillo como utilizar el operador pipe, “pasándole” el registro al bloque de medición, en este caso, de tres qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">|&gt;</span> <span class="n">Measure</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Measure(3)
</pre></div>
</div>
</div>
</div>
<p>Recordemos que en mecánica cuántica, el acto de permitir que el sistema cuántico aislado interactue con un ambiente de baja coherencia resulta en perder la superposición que antes teníamos y obtener un solo estado bien definido.</p>
<p>Los detalles de cómo sucede esto es, en general, aun un problema abierto conocido como el <a class="reference external" href="https://en.wikipedia.org/wiki/Measurement_problem">problema de medición</a>, siendo aun uno de los misterios más importantes a resolver en los fundamentos teóricos de la mecánica cuántica</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">r</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8×1 Array{Complex{Float64},2}:
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>Notamos que el estado mostrado ha colapsado de ser uan superposición a representar un estado con análogo clásico que se puede entender como un resultado definido.</p>
<p>Esto fue un ejemplo de un <strong>bloque</strong>. Los bloques consisten de operaciones generales como medición o compuertas lógicas, pero igualmente Yao nos permite realizar el proceso de medición sin tener que utilizar bloques. La mayoría de transformaciones tienen su versión fuera de bloque:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="c">## Mostrará un resultado distinto si se sigue midiendo...</span>
<span class="p">(</span><span class="n">product_state</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mb">0b10</span><span class="p">)</span> <span class="o">+</span> <span class="n">product_state</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mb">0b11</span><span class="p">))</span> <span class="o">|&gt;</span> <span class="n">measure</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1-element Array{BitBasis.BitStr{5,Int64},1}:
 00010 ₍₂₎
</pre></div>
</div>
</div>
</div>
<p>Podemos también especificar el número de veces que quisieramos medir:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">reg</span> <span class="o">=</span> <span class="n">rand_state</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 7/7
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">measure</span><span class="p">(</span><span class="n">reg</span><span class="p">;</span> <span class="n">nshots</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5-element Array{BitBasis.BitStr{7,Int64},1}:
 0101100 ₍₂₎
 1010010 ₍₂₎
 1010101 ₍₂₎
 0110111 ₍₂₎
 0101100 ₍₂₎
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="compuertas-comunes">
<h4>Compuertas comunes<a class="headerlink" href="#compuertas-comunes" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Las compuertas lógicas, fuera de bloques, son representados por sus símbolos comunes para las más utilizadas:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">typeof</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">H</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Tuple{XGate,ZGate,YGate,HGate}
</pre></div>
</div>
</div>
</div>
<p>donde sus matrices unitarias asociadas en la base canónica son:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×2 LuxurySparse.PermMatrix{Complex{Float64},Int64,Array{Complex{Float64},1},Array{Int64,1}}:
 0.0+0.0im  1.0+0.0im
 1.0+0.0im  0.0+0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span> <span class="n">mat</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×2 LuxurySparse.PermMatrix{Complex{Float64},Int64,Array{Complex{Float64},1},Array{Int64,1}}:
 0.0+0.0im  0.0-1.0im
 0.0+1.0im  0.0+0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×2 LinearAlgebra.Diagonal{Complex{Float64},Array{Complex{Float64},1}}:
 1.0+0.0im       ⋅    
     ⋅      -1.0+0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span> <span class="n">mat</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×2 Array{Complex{Float64},2}:
 0.707107+0.0im   0.707107+0.0im
 0.707107+0.0im  -0.707107+0.0im
</pre></div>
</div>
</div>
</div>
<p>No obstante, nos enfocaremos en el uso dentro de bloques. Para hacer uso de ellos en bloques, debemos especificar cuántas y cuáles compuertas estarán dentro del bloque dado. Utilizamos <code class="docutils literal notranslate"><span class="pre">repeat</span></code> para repetir una compuerta <code class="docutils literal notranslate"><span class="pre">n</span></code> veces.</p>
<p>Como ejemplo, considere el siguiente estado:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ArrayReg</span><span class="p">(</span><span class="n">bit</span><span class="s">&quot;0&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×1 Array{Complex{Float64},2}:
 1.0 + 0.0im
 0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ArrayReg</span><span class="p">(</span><span class="n">bit</span><span class="s">&quot;0&quot;</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×1 Array{Complex{Float64},2}:
 0.0 + 0.0im
 1.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">ArrayReg</span><span class="p">(</span><span class="n">bit</span><span class="s">&quot;0&quot;</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×1 Array{Complex{Float64},2}:
 1.0 + 0.0im
 0.0 + 6.9154881175379e-310im
</pre></div>
</div>
</div>
</div>
<p>La compuerta <span class="math notranslate nohighlight">\(X\)</span> de pauli se conoce como el <strong>bit flip</strong> que, como se muestra arriba, transforma el estado <span class="math notranslate nohighlight">\(|0\rangle\)</span> hacia <span class="math notranslate nohighlight">\(|1\rangle\)</span> y viceversa. Esto significa que al aplicarla dos veces, regresamos al estado original en este caso.</p>
<p>Para una lista más detallada y efecto de las compuertas más utlizadas ver <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_logic_gate">aquí</a>.</p>
<p>Aquí se está operando unqubit individual con una cantidad general <span class="math notranslate nohighlight">\(n\)</span> de compuertas secuenciales. Otra forma importante de operar es especificar la accion en un registro de <span class="math notranslate nohighlight">\(m\)</span> qubits con compuertas presentar en solamente algunos de los qubits. Considere:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span><span class="p">(</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">=&gt;</span><span class="n">X</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8×8 LuxurySparse.PermMatrix{Complex{Float64},Int64,Array{Complex{Float64},1},Array{Int64,1}}:
 0.0+0.0im  0.0+0.0im  1.0+0.0im  …  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 1.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  1.0+0.0im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im  0.0+0.0im  1.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im     1.0+0.0im  0.0+0.0im  0.0+0.0im
</pre></div>
</div>
</div>
</div>
<p>el comando <code class="docutils literal notranslate"><span class="pre">put(m,</span> <span class="pre">k=&gt;C)</span></code> coloca la compuerta <code class="docutils literal notranslate"><span class="pre">C</span></code> en el qubit <code class="docutils literal notranslate"><span class="pre">k</span></code> en el registro con <code class="docutils literal notranslate"><span class="pre">m</span></code> qubits (siendo <code class="docutils literal notranslate"><span class="pre">k&lt;m</span></code>). Esto se representa como una matriz sobre el espacio vectorial del registro entero. Para poder enlazar varios bloques <code class="docutils literal notranslate"><span class="pre">put</span></code>, utilizamos <code class="docutils literal notranslate"><span class="pre">chain</span></code> para crear una cadena de bloques</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">chain</span><span class="p">(</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">=&gt;</span><span class="n">X</span><span class="p">),</span> <span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">=&gt;</span><span class="n">Y</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Cyan">nqubits: 3</span>
<span class=" -Color -Color-Bold -Color-Bold-Blue">chain</span>
├─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">put on (2)</span>
│  └─ X
└─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">put on (1)</span>
   └─ Y
</pre></div>
</div>
</div>
</div>
<p>La cadena tiene una estructura de árbol que nos permite acceder a cada etapa como si fuese un arreglo (pues es efectivamente un subtipo de arreglo abstracto en Julia):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">chain</span><span class="p">(</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">=&gt;</span><span class="n">X</span><span class="p">),</span> <span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">=&gt;</span><span class="n">Y</span><span class="p">))[</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Cyan">nqubits: 3</span>
<span class=" -Color -Color-Bold -Color-Bold-Cyan">put on (1)</span>
└─ Y
</pre></div>
</div>
</div>
</div>
<p>La matriz asociada a la cadena será, de nuevo, un operador unitario sobre el espacio vectorial asociado a todo el registro activo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">=&gt;</span><span class="n">X</span><span class="p">),</span> <span class="n">put</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="o">=&gt;</span><span class="n">Y</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8×8 LuxurySparse.PermMatrix{Complex{Float64},Int64,Array{Complex{Float64},1},Array{Int64,1}}:
 0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+1.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0-1.0im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+1.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0-1.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  …  0.0+0.0im  0.0+1.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0-1.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="compuertas-de-control">
<h4>Compuertas de control<a class="headerlink" href="#compuertas-de-control" title="Enlazar permanentemente con este título">¶</a></h4>
<p>El diagrama mostrado al inicio del documento tenía elementos que conectan dos lineas de evolución de qubits. Estas son <strong>compuertas de control</strong> que consisten de un qubit de control y otro de respuesta.</p>
<p>El qubit de control debe estar en el estado <span class="math notranslate nohighlight">\(|1\rangle\)</span> para que el qubit de respuesta aplique la compuerta especificada. Es decir, tenemos versiones de las compuertas discutidas anteriormente que contienen un control: Control-<span class="math notranslate nohighlight">\(X\)</span>, control-<span class="math notranslate nohighlight">\(H\)</span>, etc.</p>
<p>Cabe agregar que aquí es donde comienzan a surgir efectos interesantes que contrastan el cómputo cuántico de el cómputo clásico, pues puede ser el caso que un qubit <em>colapse</em> al estado <span class="math notranslate nohighlight">\(|1\rangle\)</span> con cierta probabilidad <span class="math notranslate nohighlight">\(\alpha &lt;1\)</span>.</p>
<p>Esta propiedad se explota en algoritmos cuánticos para cargar información probabilística condicional que nos pueda garantizar encontrar lo que deseamos con menor cómputo de lo que condicionales clásicos requerirían.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">control</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Cyan">nqubits: 4</span>
<span class=" -Color -Color-Bold -Color-Bold-Red">control(3)</span>
└─ <span class=" -Color -Color-Bold -Color-Bold-White">(1,)</span> X
</pre></div>
</div>
</div>
</div>
<p>El anterior comando crea una compuerta de control <span class="math notranslate nohighlight">\(X\)</span> en un registro de tamaño <span class="math notranslate nohighlight">\(4\)</span>, con qubit de control <span class="math notranslate nohighlight">\(3\)</span> y qubit de respuesta <span class="math notranslate nohighlight">\(1\)</span>. Es decir, solamente si el qubit <span class="math notranslate nohighlight">\(3\)</span> resulta tener el estado <span class="math notranslate nohighlight">\(|1\rangle\)</span> vamos a actuar con <span class="math notranslate nohighlight">\(X\)</span> sobre <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>Es importante notar que el estado de <span class="math notranslate nohighlight">\(3\)</span> va a ser conocido hasta que realicemos la medición al final del circuito (o que se rompa la coherencia cuántica con otras interacciones con el ambiente, pero de manera ideal, sería mediante la medición controlada). Esto quiere decir que el efecto de <span class="math notranslate nohighlight">\(X\)</span> sobre <span class="math notranslate nohighlight">\(1\)</span> es probabilístico también, y no sabremos si se efectuó hasta medir (y a veces ni midiendo sabremos si un efecto particular se dio a cabo dentro de un circuito complejo).</p>
</div>
<div class="section" id="aplicando-bloques-a-registros">
<h4>Aplicando bloques a registros<a class="headerlink" href="#aplicando-bloques-a-registros" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Apliquemos todo lo anteriormente visto para crear nuestro primer circuito cuántico.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">YaoBase</span><span class="o">:</span> <span class="n">rand_unitary</span> <span class="c">## Genera matrices unitarias de manera aleatorio</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> 
				<span class="n">control</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="o">=&gt;</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.25</span><span class="nb">π</span><span class="p">)),</span> 
				<span class="n">put</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">GeneralMatrixBlock</span><span class="p">(</span><span class="n">rand_unitary</span><span class="p">(</span><span class="mi">4</span><span class="p">))),</span> 
				<span class="n">swap</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> 
				<span class="n">repeat</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="mi">5</span><span class="p">),</span> 
				<span class="n">put</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="o">=&gt;</span><span class="n">Ry</span><span class="p">(</span><span class="mf">0.6</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Cyan">nqubits: 5</span>
<span class=" -Color -Color-Bold -Color-Bold-Blue">chain</span>
├─ <span class=" -Color -Color-Bold -Color-Bold-Red">control(5)</span>
│  └─ <span class=" -Color -Color-Bold -Color-Bold-White">(3,)</span> rot(X, 0.7853981633974483)
├─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">put on (2, 3)</span>
│  └─ <span class=" -Color -Color-Red">matblock(...)</span>
├─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">put on (3, 4)</span>
│  └─ SWAP
├─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">repeat on (2, 3, 4, 5)</span>
│  └─ H
└─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">put on (2)</span>
   └─ rot(Y, 0.6)
</pre></div>
</div>
</div>
</div>
<p>Aquí vemos una cadena de bloques para actuar en un registro de 5 qubits activos. En orden se describen a continuación:</p>
<ul class="simple">
<li><p>Bloque de control de un operador de rotación (respecto al eje <span class="math notranslate nohighlight">\(x\)</span>) de fase <span class="math notranslate nohighlight">\(\pi/4\)</span>, controlado por el qubit 5 y respondiendo hacia el qubit 3 (notemos que no le ocupamos pasar el número de registros, pues estamos utilizando un constructor especial de <code class="docutils literal notranslate"><span class="pre">control</span></code> que utiliza <a class="reference external" href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>)</p></li>
<li><p>Una matriz general unitaria siendo ejecutada como compuerta lógica hacia los qubits <span class="math notranslate nohighlight">\(2\)</span> y <span class="math notranslate nohighlight">\(3\)</span>. Observe que la matriz es de rango <span class="math notranslate nohighlight">\(4=2^2\)</span>, por lo que actúa en pares de qubits.</p></li>
<li><p>Una acción de intercambio de qubits. El qubit <span class="math notranslate nohighlight">\(3\)</span> y <span class="math notranslate nohighlight">\(4\)</span> han sido intercambiados de índice.</p></li>
<li><p>Un bloque de compuertas de Hadamard, <span class="math notranslate nohighlight">\(H\)</span>, aplicadas en los qubits <span class="math notranslate nohighlight">\(2, 3\)</span>, y <span class="math notranslate nohighlight">\(4\)</span>.</p></li>
<li><p>Una rotación de fase de 0.6 radianes respecto al eje <span class="math notranslate nohighlight">\(y\)</span></p></li>
</ul>
<p>Las rotaciones aquí mencionadas son respecto a los ejes espaciales definidos con el modelo de <a class="reference external" href="https://en.wikipedia.org/wiki/Bloch_sphere">esfera de Block</a>.</p>
<p>Para aplicar este circuito a algún registro utilizamos el comando <code class="docutils literal notranslate"><span class="pre">apply!</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">apply!</span><span class="p">(</span><span class="n">zero_state</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ArrayReg{1, Complex{Float64}, Array...}
    active qubits: 5/5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>32×1 Array{Complex{Float64},2}:
 -0.18329888081201484 - 0.21777568321332402im
                  0.0 + 0.0im
 -0.07909106181919248 - 0.08899645718378356im
                  0.0 + 0.0im
 -0.18329888081201484 - 0.21777568321332402im
                  0.0 + 0.0im
 -0.07909106181919248 - 0.08899645718378356im
                  0.0 + 0.0im
 -0.23215911947521112 + 0.1185324826984002im
                  0.0 + 0.0im
 -0.05135658889588815 + 0.2901968318398861im
                  0.0 + 0.0im
 -0.23215911947521112 + 0.1185324826984002im
                      ⋮
 -0.18329888081201484 - 0.21777568321332402im
                  0.0 + 0.0im
 -0.07909106181919248 - 0.08899645718378356im
                  0.0 + 0.0im
 -0.23215911947521112 + 0.1185324826984002im
                  0.0 + 0.0im
 -0.05135658889588815 + 0.2901968318398861im
                  0.0 + 0.0im
 -0.23215911947521112 + 0.1185324826984002im
                  0.0 + 0.0im
 -0.05135658889588815 + 0.2901968318398861im
                  0.0 + 0.0im
</pre></div>
</div>
</div>
</div>
<p>Podemos explorar el caso de un registro donde no todos los qubits están activos y utilizar una notación más elegante utilizando <code class="docutils literal notranslate"><span class="pre">Pipe</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="kt">Pipe</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@pipe</span> <span class="n">zero_state</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">focus!</span><span class="p">(</span><span class="mi">1</span><span class="o">:</span><span class="mi">5</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">apply!</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">circuit</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>32×32 Array{Complex{Float64},2}:
  -0.183299-0.217776im   0.0+0.0im  …  0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 -0.0790911-0.0889965im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
  -0.183299-0.217776im   0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im  …  0.0+0.0im  0.0+0.0im  0.0+0.0im
 -0.0790911-0.0889965im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
  -0.232159+0.118532im   0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 -0.0513566+0.290197im   0.0+0.0im  …  0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
  -0.232159+0.118532im   0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
           ⋮                        ⋱                ⋮       
  -0.183299-0.217776im   0.0+0.0im  …  0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 -0.0790911-0.0889965im  0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
  -0.232159+0.118532im   0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im  …  0.0+0.0im  0.0+0.0im  0.0+0.0im
 -0.0513566+0.290197im   0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
  -0.232159+0.118532im   0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
 -0.0513566+0.290197im   0.0+0.0im  …  0.0+0.0im  0.0+0.0im  0.0+0.0im
        0.0+0.0im        0.0+0.0im     0.0+0.0im  0.0+0.0im  0.0+0.0im
</pre></div>
</div>
</div>
</div>
<p>Esto muestra el flujo completo del circuito, desde el registro, hasta la medición de su estado final.</p>
</div>
<div class="section" id="metricas-de-comparacion-de-registros">
<h4>Métricas de comparación de registros<a class="headerlink" href="#metricas-de-comparacion-de-registros" title="Enlazar permanentemente con este título">¶</a></h4>
<p>Posterior a la medición u operación de compuerta lógica hacia un registro, nos puede gustar verificar la fidelidad con la cual el estado cuántico corresponde al que esperamos de manera teórica. En la práctica, dentro de una computadora cuántica, esta fidelidad se ve comprometida en cada operación que realizamos, así como la evolución natural del sistema.</p>
<p>Algunas de estas métricas ya están implementadas en <code class="docutils literal notranslate"><span class="pre">Yao</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">fidelity</span><span class="p">(</span><span class="n">rand_state</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">rand_state</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0745484768923264
</pre></div>
</div>
</div>
</div>
<p>Ésta es calculada con la fórmula
<span class="math notranslate nohighlight">\( {\displaystyle F(\rho ,\sigma )=\left(\operatorname {tr} {\sqrt {{\sqrt {\rho }}\sigma {\sqrt {\rho }}}}\right)^{2}}\)</span>.</p>
<p>Donde <span class="math notranslate nohighlight">\(\rho\)</span> y <span class="math notranslate nohighlight">\(\sigma\)</span> son los estados del sistema (pensados en generalidad como operadores de densidad y no como su forma pura como vectores). También tenemos la distancia inducida por la traza en el espacio de estos operadores tipo traza. Éste se define como <span class="math notranslate nohighlight">\(\frac{1}{2} || \rho- \sigma||_{\text{tr}}\)</span> y se utiliza como <code class="docutils literal notranslate"><span class="pre">tracedist</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">tracedist</span><span class="p">(</span><span class="n">rand_state</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="n">rand_state</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1-element Array{Float64,1}:
 1.976473563016586
</pre></div>
</div>
</div>
</div>
<p>Ambos métricas mostradas utilizan el operador de densidad general del estado, pero al estar considerando solamente sistemas de dimensión finita, podemos representar sin ambigüedad esta en una matriz de densidad de la siguiente forma:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">rand_state</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">ρ</span><span class="p">)</span><span class="o">.</span><span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2×2×1 Array{Complex{Float64},3}:
[:, :, 1] =
 0.0185825+0.0im        -0.106247-0.0833597im
 -0.106247+0.0833597im   0.981417+0.0im
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="algoritmica">
<h2>Algorítmica<a class="headerlink" href="#algoritmica" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="transformada-cuantica-de-fourier">
<h3>Transformada cuántica de Fourier<a class="headerlink" href="#transformada-cuantica-de-fourier" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Como ejemplo de un algoritmo cuántico clásico, construiremos el circuito asociado con la <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_Fourier_transform">transformada cuántica de Fourier</a>. Este es un algoritmo que equivale a realizar la transformada inversa discreta de Fourier a una cadena de bits, pero utilizando un circuito del tipo que acabamos de construir.</p>
<p>Los detalles teóricos profundos serán omitidos dada la disponibilidad grande que hay de recursos que ya lo explican. Considere el siguiente diagrama que representa el circuito/algoritmo:</p>
<p><img alt="QFT" src="https://docs.yaoquantum.org/v0.3/assets/figures/qft.png" /></p>
<p>Este muestra el caso para un registro de <span class="math notranslate nohighlight">\(5\)</span> qubits, no obstante, programaremos el caso general para un registro de <span class="math notranslate nohighlight">\(n\)</span> qubits. El diagrama sugiere que una forma ordenada de programar este circuito es aprovechar su estructura repetitiva.</p>
<p>Tenemos el bloque A definido por una compuerta de rotación controlada cuya posición en la cadena es determinada por cuál es su qubit de control y de respuesta, así como el valor de su rotación. Estos son respectivamente <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>, y <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">(</span><span class="n">i</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">j</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">k</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span> <span class="o">=</span> <span class="n">control</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">=&gt;</span><span class="n">shift</span><span class="p">(</span><span class="mi">2</span><span class="nb">π</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>A (generic function with 1 method)
</pre></div>
</div>
</div>
</div>
<p>El bloque B que está compuesto por el patrón de <span class="math notranslate nohighlight">\(\{H, R_2, \dots, R_{n-i+1}\}\)</span> donde <span class="math notranslate nohighlight">\(i\)</span> es el índice del qubit respuesta donde es aplicado B y <span class="math notranslate nohighlight">\(n\)</span> es el número total de qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">B</span><span class="p">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">i</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="n">j</span> <span class="o">?</span> <span class="n">kron</span><span class="p">(</span><span class="n">i</span><span class="o">=&gt;</span><span class="n">H</span><span class="p">)</span> <span class="o">:</span> <span class="n">A</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">:</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>B (generic function with 1 method)
</pre></div>
</div>
</div>
</div>
<p>Finalmente, el algoritmo de QFT (Quantum Fourier Transform) es definido por una cadena sencilla de bloques B.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">QFT</span><span class="p">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">B</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>QFT (generic function with 1 method)
</pre></div>
</div>
</div>
</div>
<p>Así, acabamos de programar la versión general del circuito de QFT:</p>
<p><img alt="QFT-general" src="https://upload.wikimedia.org/wikipedia/commons/6/61/Q_fourier_nqubits.png" /></p>
<p>Aquí vemos el caso con <span class="math notranslate nohighlight">\(n = 4\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">QFT</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span><span class=" -Color -Color-Cyan">nqubits: 4</span>
<span class=" -Color -Color-Bold -Color-Bold-Blue">chain</span>
├─ <span class=" -Color -Color-Bold -Color-Bold-Blue">chain</span>
│  ├─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">kron</span>
│  │  └─ <span class=" -Color -Color-Bold -Color-Bold-White">1</span>=&gt;H
│  ├─ <span class=" -Color -Color-Bold -Color-Bold-Red">control(2)</span>
│  │  └─ <span class=" -Color -Color-Bold -Color-Bold-White">(1,)</span> shift(1.5707963267948966)
│  ├─ <span class=" -Color -Color-Bold -Color-Bold-Red">control(3)</span>
│  │  └─ <span class=" -Color -Color-Bold -Color-Bold-White">(1,)</span> shift(0.7853981633974483)
│  └─ <span class=" -Color -Color-Bold -Color-Bold-Red">control(4)</span>
│     └─ <span class=" -Color -Color-Bold -Color-Bold-White">(1,)</span> shift(0.39269908169872414)
├─ <span class=" -Color -Color-Bold -Color-Bold-Blue">chain</span>
│  ├─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">kron</span>
│  │  └─ <span class=" -Color -Color-Bold -Color-Bold-White">2</span>=&gt;H
│  ├─ <span class=" -Color -Color-Bold -Color-Bold-Red">control(3)</span>
│  │  └─ <span class=" -Color -Color-Bold -Color-Bold-White">(2,)</span> shift(1.5707963267948966)
│  └─ <span class=" -Color -Color-Bold -Color-Bold-Red">control(4)</span>
│     └─ <span class=" -Color -Color-Bold -Color-Bold-White">(2,)</span> shift(0.7853981633974483)
├─ <span class=" -Color -Color-Bold -Color-Bold-Blue">chain</span>
│  ├─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">kron</span>
│  │  └─ <span class=" -Color -Color-Bold -Color-Bold-White">3</span>=&gt;H
│  └─ <span class=" -Color -Color-Bold -Color-Bold-Red">control(4)</span>
│     └─ <span class=" -Color -Color-Bold -Color-Bold-White">(3,)</span> shift(1.5707963267948966)
└─ <span class=" -Color -Color-Bold -Color-Bold-Blue">chain</span>
   └─ <span class=" -Color -Color-Bold -Color-Bold-Cyan">kron</span>
      └─ <span class=" -Color -Color-Bold -Color-Bold-White">4</span>=&gt;H
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">qft</span> <span class="o">=</span> <span class="n">QFT</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="n">iqft</span> <span class="o">=</span> <span class="n">QFT</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="nd">@pipe</span> <span class="n">product_state</span><span class="p">(</span><span class="n">bit</span><span class="s">&quot;0110&quot;</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">apply!</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">qft</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="n">state</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>16×1 Array{Complex{Float64},2}:
    0.24999999999999992 + 0.0im
   -0.17677669529663678 + 0.17677669529663684im
 -1.530808498934191e-17 - 0.24999999999999992im
    0.17677669529663684 + 0.17677669529663678im
   -0.24999999999999992 + 0.0im
    0.17677669529663678 - 0.17677669529663684im
  1.530808498934191e-17 + 0.24999999999999992im
   -0.17677669529663684 - 0.17677669529663678im
    0.24999999999999992 + 0.0im
   -0.17677669529663678 + 0.17677669529663684im
 -1.530808498934191e-17 - 0.24999999999999992im
    0.17677669529663684 + 0.17677669529663678im
   -0.24999999999999992 + 0.0im
    0.17677669529663678 - 0.17677669529663684im
  1.530808498934191e-17 + 0.24999999999999992im
   -0.17677669529663684 - 0.17677669529663678im
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="estimacion-de-fase">
<h3>Estimación de fase<a class="headerlink" href="#estimacion-de-fase" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El algoritmo de transformada de Fourier se utiliza como una subrutina en muchos otros algoritmos. Uno de ellos es otro algoritmo básico famoso <em>phase estimation</em> (estimación de fase) que nos permite resolver el siguiente problema:</p>
<p>Sea <span class="math notranslate nohighlight">\(U\)</span> una matriz unitaria y sea <span class="math notranslate nohighlight">\(v\)</span> un vector propio de <span class="math notranslate nohighlight">\(U\)</span>, es decir, se cumple que <span class="math notranslate nohighlight">\(Uv = e^{2\pi i \theta} v\)</span> para algún <span class="math notranslate nohighlight">\(\theta\)</span>. Queremos estimar el valor de <span class="math notranslate nohighlight">\(\theta\)</span> para un <span class="math notranslate nohighlight">\(U\)</span> y <span class="math notranslate nohighlight">\(v\)</span> fijos.</p>
<p>El algoritmo de estimación de fase estima <span class="math notranslate nohighlight">\(\theta\)</span> con <a class="reference external" href="https://en.wikipedia.org/wiki/With_high_probability">alta probabilidad</a> (un término técnico en algoritmos probabilísticos que significa que aumentando el tamaño muestral nos acercamos en el límite a probabilidad 1 de estar correctos) con un número de qubits que solo ocupa crecer como <span class="math notranslate nohighlight">\(O(\log(1/\epsilon))\)</span> donde el error aditivo es <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<p>Considere el siguiente diagrama:
<img alt="fase" src="https://docs.yaoquantum.org/v0.5/assets/figures/phaseest.png" /></p>
<p>Notemos que aquí tenemos dos conjuntos independientes de registros, los primeros que van a ser transformados por las compuertas de hadamard y QFT. Éstos controlan el segundo registro, que consiste en el estado <span class="math notranslate nohighlight">\(v\)</span> y una sucesión de aplicaciones de poderes de <span class="math notranslate nohighlight">\(U\)</span> para extraer así fases múltiple de la que estamos buscando, lo cual nos servirá para estimar correctamente <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
<p>Definamos la cadena de bloques que define la sucesión de poderes de <span class="math notranslate nohighlight">\(U\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">ControlU</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> 
						  <span class="n">control</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">+</span><span class="n">m</span> <span class="o">=&gt;</span> <span class="n">matblock</span><span class="p">(</span><span class="n">U</span><span class="o">^</span><span class="p">(</span><span class="mi">2</span><span class="o">^</span><span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">))))</span> 
						  <span class="k">for</span> <span class="n">k</span> <span class="kp">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ControlU (generic function with 1 method)
</pre></div>
</div>
</div>
</div>
<p>Luego, crear el algoritmo del circuito arriba mostrado es tan sencillo como:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-julia notranslate"><div class="highlight"><pre><span></span><span class="n">PE</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="o">=</span><span class="n">chain</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">,</span> <span class="c">## Número total de qubits, sumando ambos registros.</span>
        		   <span class="n">concentrate</span><span class="p">(</span><span class="n">Hadamards</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="p">),</span> <span class="c">## H en el primer registro. </span>
        		   <span class="n">ControlU</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">U</span><span class="p">),</span>
                   <span class="n">concentrate</span><span class="p">(</span><span class="n">QFT</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PE (generic function with 1 method)
</pre></div>
</div>
</div>
</div>
<p>Este algoritmo es utilizado también como base o subrutina de otros algoritmos clásicos, por ejemplo el algoritmo de Shor para factorización de números enteros.</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "julia-1.5"
        },
        kernelOptions: {
            kernelName: "julia-1.5",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'julia-1.5'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="Natural_Language_Processing.html" title="previous page">Natural Language Processing</a>
    <a class='right-next' id="next-link" href="Primer_proyecto.html" title="next page">Primer proyecto</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Luis Felipe Flores Machado, René David Hernández<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="_static/js/index.30270b6e4c972e43c488.js"></script>


    
  </body>
</html>